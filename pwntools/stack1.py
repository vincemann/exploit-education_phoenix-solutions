from pwn import *

binary = "/opt/phoenix/i486/stack-one"
context.clear()
context.update(arch = 'i386', os = 'linux')
context.binary = binary
# context.terminal = ["bash","-c"]
context.terminal = ["tmux", "splitw", "-h"]
context.log_file = "/tmp/docgil"

# only works when debug info is availiable
# maybe write own function parsing dissably code for ebp-val and ebp+val and store those adresses
# https://stackoverflow.com/questions/55629300/gdb-python-disas-parse-output
# def find_local_vars(frame):
#     names = set()
#     block = frame.block()
#     while block:
#         if block.is_global:
#             log.warn("global block found")
#             break
#         for symbol in block:
#             if symbol.is_argument or symbol.is_variable:
#                 name = symbol.name
#                 if not name in names:
#                     print('{} = {}'.format(name, symbol.value_of_ex(frame)))
#                     names.add(name)
#         block = block.superblock
#         # found function end
#         if block.function is not None:
#             break
#     return names

arg = "A"*64

io = pwnlib.gdb.debug([binary,arg],api=True)
io_gdb = io.gdb
# io = process([binary,arg])
# pid, io_gdb = pwnlib.gdb.attach(io,api=True)
io_gdb.execute("b *0x08048564")
io_gdb.continue_and_wait()


# analyze before strcpy
main_frame = io_gdb.selected_frame()
print("main frame:")
print(main_frame)

return_adr = hex(main_frame.pc())
print("ret adr of main")
print(return_adr)

base_pointer = main_frame.read_register("ebp")
print("base pointer: ")
print(base_pointer)

buf_adr = base_pointer-0x4c
print("calculated buf adr:")
print(buf_adr)

puts, member = io_gdb.lookup_symbol("puts")
print("puts symbol:")
print(puts)

puts_adr = puts.value_of_ex()
print("puts adr:")
print(puts_adr)



bps = io_gdb.breakpoints()
for bp in bps:
    print(bp)
io_gdb.quit()
io.recvall()
# print stack and find buffer by looking for A's
# x/64w$esp




